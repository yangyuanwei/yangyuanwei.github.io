<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="As an iOS developer, nearly every line of code you write is in reaction to some event; a button tap, a received network message, a property change (via Key Value Observing) or a change in user’s locat">
<meta property="og:type" content="article">
<meta property="og:title" content="ReactiveCocoa Tutorial - The Definitive Introduction:Part 1&#x2F;2">
<meta property="og:url" content="http://yoursite.com/2017/09/11/01-ReactiveCocoa-Part1:2/index.html">
<meta property="og:site_name" content="YYW’s Blog">
<meta property="og:description" content="As an iOS developer, nearly every line of code you write is in reaction to some event; a button tap, a received network message, a property change (via Key Value Observing) or a change in user’s locat">
<meta property="og:updated_time" content="2017-09-17T10:04:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ReactiveCocoa Tutorial - The Definitive Introduction:Part 1&#x2F;2">
<meta name="twitter:description" content="As an iOS developer, nearly every line of code you write is in reaction to some event; a button tap, a received network message, a property change (via Key Value Observing) or a change in user’s locat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/11/01-ReactiveCocoa-Part1:2/"/>





  <title>ReactiveCocoa Tutorial - The Definitive Introduction:Part 1/2 | YYW’s Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YYW’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            Über
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/01-ReactiveCocoa-Part1:2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yangyuanwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YYW’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ReactiveCocoa Tutorial - The Definitive Introduction:Part 1/2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T22:36:18+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>As an iOS developer, nearly every line of code you write is in reaction to some event; a button tap, a received network message, a property change (via Key Value Observing) or a change in user’s location via CoreLocation are all good examples. However, these events are all encoded in different ways; as actions, delegates, KVO, callbacks and others. ReactiveCocoa defines a standard interface for events, so they can be more easily chained, filtered and composed using a basic set of tools.</p>
<p>Sound confusing? Intriguing? … Mind blowing? Then read on :]</p>
<p>ReactiveCocoa combines a couple of programming styles:</p>
<p>Functional Programming which makes use of higher order functions, i.e. functions which take other functions as their arguments<br>Reactive Programming which focuses of data-flows and change propagation<br>For this reason, you might hear ReactiveCocoa described as a Functional Reactive Programming (or FRP) framework.</p>
<p>Rest assured, that is as academic as this tutorial is going to get! Programming paradigms are a fascinating subject, but the rest of this ReactiveCocoa tutorials focuses solely on the practical value, with work-through examples instead of academic theories.</p>
<p>The Reactive Playground</p>
<p>Throughout this ReactiveCocoa tutorial, you’ll be introducing reactive programming to a very simple example application, the ReactivePlayground. Download the starter project, then build and run to verify you have everything set up correctly.</p>
<p>ReactivePlayground is a very simple app that presents a sign-in screen to the user. Supply the correct credentials, which are, somewhat imaginatively, user for the username, and password for the password, and you’ll be greeted by a picture of a lovely little kitten.</p>
<p>Awww! How cute!</p>
<p>Right now it’s a good point to spend a little time looking through the code of this starter project. It is quite simple, so it shouldn’t take long.</p>
<p>Open RWViewController.m and take a look around. How quickly can you identify the condition that results in the enabling of the Sign In button? What are the rules for showing / hiding the signInFailure label? In this relatively simple example, it might take only a minute or two to answer these questions. For a more complex example, you should be able to see how this same type of analysis might take quite a bit longer.</p>
<p>With the use of ReactiveCocoa, the underlying intent of the application will become a lot clearer. It’s time to get started!</p>
<p>Adding the ReactiveCocoa Framework</p>
<p>The easiest way to add the ReactiveCocoa framework to your project is via CocoaPods. If you’ve never used CocoaPods before it might make sense to follow the Introduction To CocoaPods tutorial on this site, or at the very least run through the initial steps of that tutorial so you can install the prerequisites.</p>
<p>Note: If for some reason you don’t want to use CocoaPods you can still use ReactiveCocoa, just follow the Importing ReactiveCocoa steps in the documentation on GitHub.</p>
<p>If you still have the ReactivePlayground project open in Xcode, then close it now. CocoaPods will create an Xcode workspace, which you’ll want to use instead of the original project file.</p>
<p>Open Terminal. Navigate to the folder where your project is located and type the following:</p>
<p>touch Podfile<br>open -e Podfile</p>
<p>This creates an empty file called Podfile and opens it with TextEdit. Copy and paste the following lines into the TextEdit window:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">platform :ios, <span class="string">'7.0'</span></div><div class="line"></div><div class="line">pod <span class="string">'ReactiveCocoa'</span>, <span class="string">'2.1.8'</span></div></pre></td></tr></table></figure>
<p>This sets the platform to iOS, the minimum SDK version to 7.0, and adds the ReactiveCocoa framework as a dependency.</p>
<p>Once you’ve saved this file, go back to the Terminal window and issue the following command:</p>
<p>pod install</p>
<p>You should see an output similar to the following:</p>
<p>Analyzing dependencies<br>Downloading dependencies<br>Installing ReactiveCocoa (2.1.8)<br>Generating Pods project<br>Integrating client project</p>
<p>[!] From now on use <code>RWReactivePlayground.xcworkspace</code>.</p>
<p>This indicates that the ReactiveCocoa framework has been downloaded, and CocoaPods has created an Xcode workspace to integrate the framework into your existing application.</p>
<p>Open up the newly generated workspace, RWReactivePlayground.xcworkspace, and look at the structure CocoaPods created inside the Project Navigator:</p>
<p>You should see that CocoaPods created a new workspace and added the original project, RWReactivePlayground, together with a Pods project that includes ReactiveCocoa. CocoaPods really does make managing dependencies a breeze!</p>
<p>You’ll notice this project’s name is ReactivePlayground, so that must mean it’s time to play …</p>
<p>Time To Play</p>
<p>As mentioned in the introduction, ReactiveCocoa provides a standard interface for handling the disparate stream of events that occur within your application. In ReactiveCocoa terminology these are called signals, and are represented by the RACSignal class.</p>
<p>Open the initial view controller for this app, RWViewController.m, and import the ReactiveCocoa header by adding the following to the top of the file:</p>
<p>#import <reactivecocoa reactivecocoa.h=""></reactivecocoa></p>
<p>You aren’t going to replace any of the existing code just yet, for now you’re just going to play around a bit. Add the following code to the end of the viewDidLoad method:</p>
<p>[self.usernameTextField.rac_textSignal subscribeNext:^(id x) {<br>NSLog(@”%@”, x);<br>}];</p>
<p>Build and run the application and type some text into the username text field. Keep an eye on the console and look for an output similar to the following:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">2013-12-24 14:48:50.359 RWReactivePlayground[9193:a0b] i</div><div class="line">2013-12-24 14:48:50.436 RWReactivePlayground[9193:a0b] is</div><div class="line">2013-12-24 14:48:50.541 RWReactivePlayground[9193:a0b] is </div><div class="line">2013-12-24 14:48:50.695 RWReactivePlayground[9193:a0b] is t</div><div class="line">2013-12-24 14:48:50.831 RWReactivePlayground[9193:a0b] is th</div><div class="line">2013-12-24 14:48:50.878 RWReactivePlayground[9193:a0b] is thi</div><div class="line">2013-12-24 14:48:50.901 RWReactivePlayground[9193:a0b] is this</div><div class="line">2013-12-24 14:48:51.009 RWReactivePlayground[9193:a0b] is this </div><div class="line">2013-12-24 14:48:51.142 RWReactivePlayground[9193:a0b] is this m</div><div class="line">2013-12-24 14:48:51.236 RWReactivePlayground[9193:a0b] is this ma</div><div class="line">2013-12-24 14:48:51.335 RWReactivePlayground[9193:a0b] is this mag</div><div class="line">2013-12-24 14:48:51.439 RWReactivePlayground[9193:a0b] is this magi</div><div class="line">2013-12-24 14:48:51.535 RWReactivePlayground[9193:a0b] is this magic</div><div class="line">2013-12-24 14:48:51.774 RWReactivePlayground[9193:a0b] is this magic?</div></pre></td></tr></table></figure>
<p>You can see that each time you change the text within the text field, the code within the block executes. No target-action, no delegates — just signals and blocks. That’s pretty exciting!</p>
<p>ReactiveCocoa signals (represented by RACSignal) send a stream of events to their subscribers. There are three types of events to know: next, error and completed. A signal may send any number of next events before it terminates after an error, or it completes. In this part of the tutorial you’ll focus on the next event. Be sure to read part two when it’s available to learn about error and completed events.</p>
<p>RACSignal has a number of methods you can use to subscribe to these different event types. Each method takes one or more blocks, with the logic in your block executing when an event occurs. In this case, you can see that the subscribeNext: method was used to supply a block that executes on each next event.</p>
<p>The ReactiveCocoa framework uses categories to add signals to many of the standard UIKit controls so you can add subscriptions to their events, which is where the rac_textSignal property on the text field came from.</p>
<p>But enough with the theory, it’s time to start making ReactiveCocoa do some work for you!</p>
<p>ReactiveCocoa has a large range of operators you can use to manipulate streams of events. For example, assume you’re only interested in a username if it’s more than three characters long. You can achieve this by using the filter operator. Update the code you added previously in viewDidLoad to the following:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[[self.usernameTextField.rac_textSignal</div><div class="line">filter:^BOOL(id value) &#123;</div><div class="line">NSString *text = value;</div><div class="line"><span class="built_in">return</span> text.length &gt; 3;</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>If you build and run, then type some text into the text field, you should find that it only starts logging when the text field length is greater than three characters:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.335</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">t</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.478</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">th</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.526</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">thi</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.548</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.676</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> </div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.798</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">m</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.926</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">ma</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:51.987</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">mag</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:52.141</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">magi</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:52.229</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">magic</span></div><div class="line">2013<span class="selector-tag">-12-26</span> 08<span class="selector-pseudo">:17</span><span class="selector-pseudo">:52.486</span> <span class="selector-tag">RWReactivePlayground</span><span class="selector-attr">[9654:a0b]</span> <span class="selector-tag">is</span> <span class="selector-tag">this</span> <span class="selector-tag">magic</span>?</div></pre></td></tr></table></figure>
<p>What you’ve created here is a very simple pipeline. It is the very essence of Reactive Programming, where you express your application’s functionality in terms of data flows.</p>
<p>It can help to picture these flows graphically:</p>
<p>In the above diagram you can see that the rac_textSignal is the initial source of events. The data flows through a filter that only allows events to pass if they contain a string with a length that is greater than three. The final step in the pipeline is subscribeNext: where your block logs the event value.</p>
<p>At this point it’s worth noting that the output of the filter operation is also an RACSignal. You could arrange the code as follows to show the discrete pipeline steps:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameSourceSignal = </div><div class="line">self.usernameTextField.rac_textSignal;</div><div class="line"></div><div class="line">RACSignal *filteredUsername = [usernameSourceSignal  </div><div class="line">filter:^BOOL(id value) &#123;</div><div class="line">NSString *text = value;</div><div class="line"><span class="built_in">return</span> text.length &gt; 3;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[filteredUsername subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>Because each operation on an RACSignal also returns an RACSignal it’s termed a fluent interface. This feature allows you to construct pipelines without the need to reference each step using a local variable.</p>
<p>Note: ReactiveCocoa makes heavy use of blocks. If you’re new to blocks, you might want to read Apple’s Blocks Programming Topics. And if, like me, you’re familiar with blocks, but find the syntax a little confusing and hard to remember, you might find the amusingly titled f<strong>*</strong>gblocksyntax.com quite useful! (We censored the word to protect the innocent, but the link is fully functional.)<br>A Little Cast</p>
<p>If you updated your code to split it into the various RACSignal components, now is the time to revert it back to the fluent syntax:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[[self.usernameTextField.rac_textSignal</div><div class="line">filter:^BOOL(id value) &#123;</div><div class="line">NSString *text = value; // implicit cast</div><div class="line"><span class="built_in">return</span> text.length &gt; 3;</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>The implicit cast from id to NSString, at the indicated location in the code above, is less than elegant. Fortunately, since the value passed to this block is always going to be an NSString, you can change the parameter type itself. Update your code as follows:</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[self.usernameTextField.rac_textSignal</div><div class="line">filter:^BOOL(NSString *text) &#123;</div><div class="line"><span class="built_in">return</span> text.length &gt; 3;</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>Build and run to confirm this works just as it did previously.</p>
<p>What’s An Event?</p>
<p>So far this tutorial has described the different event types, but hasn’t detailed the structure of these events. What’s interesting is that an event can contain absolutely anything!</p>
<p>As an illustration of this point, you’re going to add another operation to the pipeline. Update the code you added to viewDidLoad as follows:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[[self.usernameTextField.rac_textSignal</div><div class="line">map:^id(NSString *text) &#123;</div><div class="line"><span class="built_in">return</span> @(text.length);</div><div class="line">&#125;]</div><div class="line">filter:^BOOL(NSNumber *length) &#123;</div><div class="line"><span class="built_in">return</span> [length integerValue] &gt; 3;</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>If you build and run you’ll find the app now logs the length of the text instead of the contents:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">2013-12-26 12:06:54.566 RWReactivePlayground[10079:a0b] 4</div><div class="line">2013-12-26 12:06:54.725 RWReactivePlayground[10079:a0b] 5</div><div class="line">2013-12-26 12:06:54.853 RWReactivePlayground[10079:a0b] 6</div><div class="line">2013-12-26 12:06:55.061 RWReactivePlayground[10079:a0b] 7</div><div class="line">2013-12-26 12:06:55.197 RWReactivePlayground[10079:a0b] 8</div><div class="line">2013-12-26 12:06:55.300 RWReactivePlayground[10079:a0b] 9</div><div class="line">2013-12-26 12:06:55.462 RWReactivePlayground[10079:a0b] 10</div><div class="line">2013-12-26 12:06:55.558 RWReactivePlayground[10079:a0b] 11</div><div class="line">2013-12-26 12:06:55.646 RWReactivePlayground[10079:a0b] 12</div></pre></td></tr></table></figure>
</code></pre><p>The newly added map operation transforms the event data using the supplied block. For each next event it receives, it runs the given block and emits the return value as a next event. In the code above, the map takes the NSString input and takes its length, which results in an NSNumber being returned.</p>
<p>For a stunning graphic depiction of how this works, take a look at this image:</p>
<p>As you can see, all of the steps that follow the map operation now receive NSNumber instances. You can use the map operation to transform the received data into anything you like, as long as it’s an object.</p>
<p>Note: In the above example the text.length property returns an NSUInteger, which is a primitive type. In order to use it as the contents of an event, it must be boxed. Fortunately the Objective-C literal syntax provides and option to do this in a rather concise manner – @(text.length).<br>That’s enough playing! It’s time to update the ReactivePlayground app to use the concepts you’ve learned so far. You may remove all of the code you’ve added since you started this tutorial.</p>
<p>Creating Valid State Signals</p>
<p>The first thing you need to do is create a couple of signals that indicate whether the username and password text fields are valid. Add the following to the end of viewDidLoad in RWViewController.m:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RACSignal *validUsernameSignal =</div><div class="line">[self.usernameTextField.rac_textSignal</div><div class="line">map:^id(NSString *text) &#123;</div><div class="line"><span class="built_in">return</span> @([self isValidUsername:text]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *validPasswordSignal =</div><div class="line">[self.passwordTextField.rac_textSignal</div><div class="line">map:^id(NSString *text) &#123;</div><div class="line"><span class="built_in">return</span> @([self isValidPassword:text]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>As you can see, the above code applies a map transform to the rac_textSignal from each text field. The output is a boolean value boxed as a NSNumber.</p>
<p>The next step is to transform these signals so that they provide a nice background color to the text fields. Basically, you subscribe to this signal and use the result to update the text field background color. One viable option is as follows:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[validPasswordSignal</div><div class="line">map:^id(NSNumber *passwordValid) &#123;</div><div class="line"><span class="built_in">return</span> [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(UIColor *color) &#123;</div><div class="line">self.passwordTextField.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><p>(Please don’t add this code, there’s a much more elegant solution coming!)</p>
<p>Conceptually you’re assigning the output of this signal to the backgroundColor property of the text field. However, the code above is a poor expression of this; it’s all backwards!</p>
<p>Fortunately, ReactiveCocoa has a macro that allows you to express this with grace and elegance. Add the following code directly beneath the two signals you added to viewDidLoad:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RAC(self.passwordTextField, backgroundColor) =</div><div class="line">[validPasswordSignal</div><div class="line">map:^id(NSNumber *passwordValid) &#123;</div><div class="line"><span class="built_in">return</span> [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(self.usernameTextField, backgroundColor) =</div><div class="line">[validUsernameSignal</div><div class="line">map:^id(NSNumber *passwordValid) &#123;</div><div class="line"><span class="built_in">return</span> [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>The RAC macro allows you to assign the output of a signal to the property of an object. It takes two arguments, the first is the object that contains the property to set and the second is the property name. Each time the signal emits a next event, the value that passes is assigned to the given property.</p>
<p>This is a very elegant solution, don’t you think?</p>
<p>One last thing before you build and run. Locate the updateUIState method and remove the first two lines:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];</div></pre></td></tr></table></figure></p>
<p>That will clean up the non-reactive code.</p>
<p>Build and run the application. You should find that the text fields look highlighted when invalid, and clear when valid.</p>
<p>Visuals are nice, so here is a way to visualize the current logic. Here you can see two simple pipelines that take the text signals, map them to validity-indicating booleans, and then follow with a second mapping to a UIColorwhich is the part that binds to the background color of the text field.</p>
<p>Are you wondering why you created separate validPasswordSignal and validUsernameSignal signals, as opposed to a single fluent pipeline for each text field? Patience dear reader, the method behind this madness will become clear shortly!</p>
<p>Combining signals</p>
<p>In the current app, the Sign In button only works when both the username and password text fields have valid input. It’s time to do this reactive-style!</p>
<p>The current code already has signals that emit a boolean value to indicate if the username and password fields are valid; validUsernameSignal and validPasswordSignal. Your task is to combine these two signals to determine when it is okay to enable the button.</p>
<p>At the end of viewDidLoad add the following:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RACSignal *signUpActiveSignal =</div><div class="line">[RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</div><div class="line">reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</div><div class="line"><span class="built_in">return</span> @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>The above code uses the combineLatest:reduce: method to combine the latest values emitted by validUsernameSignal and validPasswordSignal into a shiny new signal. Each time either of the two source signals emits a new value, the reduce block executes, and the value it returns is sent as the next value of the combined signal.</p>
<p>Note: The RACSignal combine methods can combine any number of signals, and the arguments of the reduce block correspond to each of the source signals. ReactiveCocoa has a cunning little utility class, RACBlockTrampoline that handles the reduce block’s variable argument list internally. In fact, there are a lot of cunning tricks hidden within the ReactiveCocoa implementation, so it’s well worth pulling back the covers!<br>Now that you have a suitable signal, add the following to the end of viewDidLoad. This will wire it up to the enabled property on the button:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</div><div class="line">self.signInButton.enabled = [signupActive boolValue];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>Before running this code, it’s time to rip out the old implementation. Remove these two properties from the top of the file:</p>
<p>@property (nonatomic) BOOL passwordIsValid;<br>@property (nonatomic) BOOL usernameIsValid;</p>
<p>From near the top of viewDidLoad, remove the following:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// handle text changes <span class="keyword">for</span> both text fields</div><div class="line">    [self.usernameTextField addTarget:self</div><div class="line">    action:@selector(usernameTextFieldChanged)</div><div class="line">    forControlEvents:UIControlEventEditingChanged];</div><div class="line">    [self.passwordTextField addTarget:self </div><div class="line">    action:@selector(passwordTextFieldChanged)</div><div class="line">    forControlEvents:UIControlEventEditingChanged];</div></pre></td></tr></table></figure></p>
<p>Also remove the updateUIState, usernameTextFieldChanged and passwordTextFieldChanged methods. Whew! That’s a lot of non-reactive code you just disposed of! You’ll be thankful you did.</p>
<p>Finally, make sure to remove the call to updateUIState from viewDidLoad as well.</p>
<p>If you build and run, check the Sign In button. It should be enabled because the username and password text fields are valid, as they were before.</p>
<p>An update to the application logic diagram gives the following:</p>
<p>The above illustrates a couple of important concepts that allow you to perform some pretty powerful tasks with ReactiveCocoa;</p>
<p>Splitting – signals can have multiple subscribers and serve as the source for more multiple subsequent pipeline steps. In the above diagram, note that the boolean signals that indicate password and username validity are split and used for a couple of different purposes.<br>Combining – multiple signals may be combined to create new signals. In this case, two boolean signals were combined. However, you can combine signals that emit any value type.<br>The result of these changes is the application no longer has private properties that indicate the current valid state of the two text fields. This is one of the key differences you’ll find when you adopt a reactive style — you don’t need to use instance variables to track transient state.</p>
<p>Reactive Sign-in</p>
<p>The application currently uses the reactive pipelines illustrated above to manage the state of the text fields and button. However, the button press handling still uses actions, so the next step is to replace the remaining application logic in order to make it all reactive!</p>
<p>The Touch Up Inside event on the Sign In button is wired up to the signInButtonTouched method in RWViewController.m via a storyboard action. You’re going to replace this with the reactive equivalent, so you first need to disconnect the current storyboard action.</p>
<p>Open up Main.storyboard, locate the Sign In button, ctrl-click to bring up the outlet / action connections and click the x to remove the connection. If you feel a little lost, the diagram below kindly shows where to find the delete button:</p>
<p>You’ve already seen how the ReactiveCocoa framework adds properties and methods to the standard UIKit controls. So far you’ve used rac_textSignal, which emits events when the text changes. In order to handle events you need to use another of the methods that ReactiveCocoa adds to UIKit, rac_signalForControlEvents.</p>
<p>Returning to RWViewController.m, add the following to the end of viewDidLoad:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[self.signInButton</div><div class="line">rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"button clicked"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>The above code creates a signal from the button’s UIControlEventTouchUpInside event and adds a subscription to make a log entry every time this event occurs.</p>
<p>Build and run to confirm the message actually logs. Bear in mind that the button will enable only when the username and password are valid, so be sure to type some text into both fields before tapping the button!</p>
<p>You should see messages in the Xcode console similar to the following:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2013-12-28 08:05:10.816 RWReactivePlayground[18203:a0b] button clicked</div><div class="line">2013-12-28 08:05:11.675 RWReactivePlayground[18203:a0b] button clicked</div><div class="line">2013-12-28 08:05:12.605 RWReactivePlayground[18203:a0b] button clicked</div><div class="line">2013-12-28 08:05:12.766 RWReactivePlayground[18203:a0b] button clicked</div><div class="line">2013-12-28 08:05:12.917 RWReactivePlayground[18203:a0b] button clicked</div></pre></td></tr></table></figure></p>
<p>Now that the button has a signal for the touch event, the next step is to wire this up with the sign-in process itself. This presents something of a problem — but that’s good, you don’t mind a problem, right? Open up RWDummySignInService.h and take a look at the interface:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RWSignInResponse)(<span class="built_in">BOOL</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWDummySignInService</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)signInWithUsername:(<span class="built_in">NSString</span> *)username</div><div class="line">password:(<span class="built_in">NSString</span> *)password </div><div class="line">complete:(RWSignInResponse)completeBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>This service takes a username, a password and a completion block as parameters. The given block is run when the sign-in is successful or when it fails. You could use this interface directly within the subscribeNext: block that currently logs the button touch event, but why would you? This is the kind of asynchronous, event-based behavior that ReactiveCocoa eats for breakfast!</p>
<p>Note: A dummy service is being used in this tutorial for simplicity, so that you don’t have any dependencies on external APIs. However, you’ve now run up against a very real problem, how do you use APIs not expressed in terms of signals?<br>Creating Signals</p>
<p>Fortunately, it’s rather easy to adapt existing asynchronous APIs to be expressed as a signal. First, remove the current signInButtonTouched: method from the RWViewController.m. You don’t need this logic as it will be replaced with a reactive equivalent.</p>
<p>Stay in RWViewController.m and add the following method:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signInSignal &#123;</div><div class="line"><span class="built_in">return</span> [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">[self.signInService</div><div class="line">signInWithUsername:self.usernameTextField.text</div><div class="line">password:self.passwordTextField.text</div><div class="line">complete:^(BOOL success) &#123;</div><div class="line">[subscriber sendNext:@(success)];</div><div class="line">[subscriber sendCompleted];</div><div class="line">&#125;];</div><div class="line"><span class="built_in">return</span> nil;</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The above method creates a signal that signs in with the current username and password. Now for a breakdown of its component parts.</p>
<p>The above code uses the createSignal: method on RACSignal for signal creation. The block that describes this signal is a single argument, and is passed to this method. When this signal has a subscriber, the code within this block executes.</p>
<p>The block is passed a single subscriber instance that adopts the RACSubscriber protocol, which has methods you invoke in order to emit events; you may also send any number of next events, terminated with either an error or complete event. In this case, it sends a single next event to indicate whether the sign-in was a success, followed by a complete event.</p>
<p>The return type for this block is an RACDisposable object, and it allows you to perform any clean-up work that might be required when a subscription is cancelled or trashed. This signal does not have any clean-up requirements, hence nil is returned.</p>
<p>As you can see, it’s surprisingly simple to wrap an asynchronous API in a signal!</p>
<p>Now to make use of this new signal. Update the code you added to the end of viewDidLoad in the previous section as follows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[[[self.signInButton</div><div class="line">rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">map:^id(id x) &#123;</div><div class="line"><span class="built_in">return</span> [self signInSignal];</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>The above code uses the map method used earlier to transform the button touch signal into the sign-in signal. The subscriber simply logs the result.</p>
<p>If you build and run, then tap the Sign In button, and take a look at the Xcode console, you’ll see the result of the above code …</p>
<p>… and the result isn’t quite what you might have expected!<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign <span class="keyword">in</span> result:</div><div class="line">&lt;RACDynamicSignal: 0xa068a00&gt; name: +createSignal:</div></pre></td></tr></table></figure></p>
<p>The subscribeNext: block has been passed a signal all right, but not the result of the sign-in signal!</p>
<p>Time to illustrate this pipeline so you can see what’s going on:</p>
<p>The rac_signalForControlEvents emits a next event (with the source UIButton as its event data) when you tap the button. The map step creates and returns the sign-in signal, which means the following pipeline steps now receive a RACSignal. That is what you’re observing at the subscribeNext: step.</p>
<p>The situation above is sometimes called the signal of signals; in other words an outer signal that contains an inner signal. If you really wanted to, you could subscribe to the inner signal within the outer signal’s subscribeNext: block. However it would result in a nested mess! Fortunately, it’s a common problem, and ReactiveCocoa is ready for this scenario.</p>
<p>Signal of Signals</p>
<p>The solution to this problem is straightforward, just change the map step to a flattenMap step as shown below:</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[[[self.signInButton</div><div class="line">rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">flattenMap:^id(id x) &#123;</div><div class="line"><span class="built_in">return</span> [self signInSignal];</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x) &#123;</div><div class="line">NSLog(@<span class="string">"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>This maps the button touch event to a sign-in signal as before, but also flattens it by sending the events from the inner signal to the outer signal.</p>
<p>Build and run, and keep an eye on the console. It should now log whether the sign-in was successful or not:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign <span class="keyword">in</span> result: 0</div><div class="line">2013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign <span class="keyword">in</span> result: 1</div></pre></td></tr></table></figure></p>
<p>Exciting stuff!</p>
<p>Now that the pipeline is doing what you want, the final step is to add the logic to the subscribeNext step to perform the required navigation upon successful sign-in. Replace the pipeline with the following:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[[[self.signInButton</div><div class="line">rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">flattenMap:^id(id x) &#123;</div><div class="line"><span class="built_in">return</span> [self signInSignal];</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(NSNumber *signedIn) &#123;</div><div class="line">BOOL success = [signedIn boolValue];</div><div class="line">self.signInFailureText.hidden = success;</div><div class="line"><span class="keyword">if</span> (success) &#123;</div><div class="line">[self performSegueWithIdentifier:@<span class="string">"signInSuccess"</span> sender:self];</div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>The subscribeNext: block takes the result from the sign-in signal, updates the visibility of the signInFailureText text field accordingly, and performs the navigation segue if required.</p>
<p>Build and run to enjoy the kitten once more! Meow!</p>
<p>Did you notice there is one small user experience issue with the current application? When the sign-in service validates the supplied credentials, is should disable the Sign In button. This prevents the user from repeating the same sign-in. Furthermore, if a failed sign-in attempt occurred, the error message should be hidden when the user tries to sign-in once again.</p>
<p>But how should you add this logic to the current pipeline? Changing the button’s enabled state isn’t a transformation, filter or any of the other concepts you’ve encountered so far. Instead, it’s what is known as a side-effect; or logic you want to execute within a pipeline when a next event occurs, but it does not actually change the nature of the event itself.</p>
<p>Adding side-effects</p>
<p>Replace the current pipeline with the following:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[[[[self.signInButton</div><div class="line">rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">doNext:^(id x) &#123;</div><div class="line">self.signInButton.enabled = NO;</div><div class="line">self.signInFailureText.hidden = YES;</div><div class="line">&#125;]</div><div class="line">flattenMap:^id(id x) &#123;</div><div class="line"><span class="built_in">return</span> [self signInSignal];</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(NSNumber *signedIn) &#123;</div><div class="line">self.signInButton.enabled = YES;</div><div class="line">BOOL success = [signedIn boolValue];</div><div class="line">self.signInFailureText.hidden = success;</div><div class="line"><span class="keyword">if</span> (success) &#123;</div><div class="line">[self performSegueWithIdentifier:@<span class="string">"signInSuccess"</span> sender:self];</div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>You can see how the above adds a doNext: step to the pipeline immediately after button touch event creation. Notice that the doNext: block does not return a value, because it’s a side-effect; it leaves the event itself unchanged.</p>
<p>The doNext: block above sets the button enabled property to NO, and hides the failure text. Whilst the subscribeNext: block re-enables the button, and either displays or hides the failure text based on the result of the sign-in.</p>
<p>It’s time to update the pipeline diagram to include this side effect. Bask in all it’s glory:</p>
<p>Build and run the application to confirm the Sign In button enables and disables as expected.</p>
<p>And with that, your work is done – the application is now fully reactive. Woot!</p>
<p>If you got lost along the way, you can download the final project (complete with dependencies), or you can obtain the code from GitHub, where there is a commit to match each build and run step in this tutorial.</p>
<p>Note: Disabling buttons while some asynchronous activity is underway is a common problem, and once again ReactiveCocoa is all over this little snafu. The RACCommand encapsulates this concept, and has an enabled signal that allows you to wire up the enabled property of a button to a signal. You might want to give the class a try.</p>
<p>Conclusions</p>
<p>Want to learn even faster? Save time with ourvideo courses<br>Hopefully this tutorial has given you a good foundation that will help you when starting to use ReactiveCocoa in your own applications. It can take a bit of practice to get used to the concepts, but like any language or program, once you get the hang of it it’s really quite simple. At the very core of ReactiveCocoa are signals, which are nothing more than streams of events. What could be simpler than that?</p>
<p>With ReactiveCocoa one of the interesting things I have found is there are numerous ways in which you can solve the same problem. You might want to experiment with this application, and adjust the signals and pipelines to change the way they split and combine.</p>
<p>It’s worth considering that the main goal of ReactiveCocoa is to make your code cleaner and easier to understand. Personally I find it easier to understand what an application does if its logic is represented as clear pipelines, using the fluent syntax.</p>
<p>​</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/11/00-MyFirstBlog/" rel="prev" title="My first Blog">
                My first Blog <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">yangyuanwei</p>
            <p class="site-description motion-element" itemprop="description">just do it</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yangyuanwei</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
